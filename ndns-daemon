#!/usr/bin/env python
# -*- Mode:python; c-file-style:"gnu"; indent-tabs-mode:nil -*- */
#
# Copyright (c) 2013, Regents of the University of California
#                     Alexander Afanasyev
#
# BSD license, See the doc/LICENSE file for more information
#
# Author: Alexander Afanasyev <alexander.afanasyev@ucla.edu>
#

# make sure modules from lib/ are loaded
import sys
_WORKDIR = sys.path[0]
sys.path = ["%s/lib" % _WORKDIR] + sys.path

import sqlite3, iscpy, argparse, time, logging, logging.handlers
import os, functools, signal, daemon

#install from contrib/
import setproctitle
import pyccn
import dns.rdataclass, dns.rdatatype, dns.rdata, dns.rrset, dns.zone

# part of lib/
import ndns

######################################################################
######################################################################
######################################################################

parser = argparse.ArgumentParser(description='NDNS daemon')
parser.add_argument('-f', dest='foreground', action='store_true', default=False,
                    help='''Keep daemon in foreground (do not daemonize)''')
parser.add_argument('-d', dest='debug', action='store_true', default=False,
                    help='''Include debug information in log output''')
parser.add_argument('-q', dest='quiet', action='store_true', default=False,
                    help='''Be quiet and do not write anything to stderr''')
parser.add_argument('-l', dest='logfile', type=str,
                    help='''Write logging to the specified logfile''')
args = parser.parse_args()

_LOG = logging.getLogger ("ndns.Daemon")
_LOG.setLevel (logging.DEBUG if (args.debug) else logging.WARN)

if args.foreground and not args.quiet:
    _handler = logging.StreamHandler (sys.stderr)
    _handler.setLevel (logging.DEBUG if (args.debug) else logging.WARN)
    _handler.setFormatter (logging.Formatter('%(asctime)s %(name)s [%(levelname)s]  %(message)s', '%H:%M:%S'))
    _LOG.addHandler (_handler)

if args.logfile:
    _handler = logging.handlers.RotatingFileHandler (args.logfile, maxBytes=10000000, backupCount=10)
    _handler.setLevel (logging.DEBUG if (args.debug) else logging.WARN)
    _handler.setFormatter (logging.Formatter('%(asctime)s %(name)s [%(levelname)s]  %(message)s'))
    _LOG.addHandler (_handler)

if ((args.quiet or not args.foreground) and not args.logfile):
    _LOG.addHandler (logging.NullHandler ())

######################################################################
######################################################################
######################################################################

class NdnsDaemon:
#public:
    def __init__ (self):
        setproctitle.setproctitle ("ndns-daemon")
        self._zones = []

    def run (self):
        _LOG.info ('Daemon started')

        self._ndns = ndns.ndns_session ()
        self._face = pyccn.CCN ()

        self._startZoneServing ()

        self._eventLoop = pyccn.EventLoop (self._face)
        self._eventLoop.run ()

        _LOG.info ('Daemon stopped')

    def terminate (self):
        self._stopZoneServing ()
        self._eventLoop.stop ()
        self._face = None
        self._ndns = None

    def reloadConfig (self):
        _LOG.info ('Reload zone information')
        self._stopZoneServing ()
        self._startZoneServing ()

    def updateLocalPrefix (self, oldPrefix, newPrefix):
        _LOG.info ("Update local prefix from [%s] to [%s]" % (oldPrefix, newPrefix))
        pass

#private:
    def _startZoneServing (self):
        for zone in self._ndns.query (ndns.Zone):
            _LOG.info ('>> Start serving zone [%s]' % zone.name)
            self._face.setInterestFilterSimple (zone.name.append ("DNS"),
                                                functools.partial (self._onRequest, zone))
            self._zones.append (zone)

    def _stopZoneServing (self):
        for zone in self._zones:
            _LOG.info ('<< Stop serving zone [%s]' % zone.name)
            self._face.clearInterestFilter (zone.name.append ("DNS"))
        self._zones = []

    def _onRequest (self, zone, basename, interest):
        _LOG.debug (">> basename [%s], interest [%s]" % (basename, interest.name))

        _LOG.debug ("zoneId: [%d], zoneName: [%s]" % (zone.id, zone.name))

        if (len(interest.name) <= len(zone.name) + 1):
            _LOG.debug ("Invalid request. Ignoring")
            return pyccn.RESULT_OK


        if interest.name[-1][0] == '\xFD':
            # allow version to be specified, but ignore it for the database lookup
            request_name = pyccn.Name (interest.name[:-1])
        else:
            request_name = interest.name

        try:
            rrtype = dns.rdatatype.from_text (request_name[-1])
        except Exception, e:
            _LOG.debug ("Invalid request: unknown or unrecognized RR type [%s] (%s)" % (request_name[-1], e))
            return pyccn.RESULT_OK

        try:
            label = dns.name.from_text (ndns.dnsify (str (pyccn.Name (request_name[len(basename):-1])))).relativize (origin = dns.name.root)
        except Exception, e:
            _LOG.debug ("Invalid request: label [%s] cannot be dnsified (%s)" % (request_name[len(basename):-1], e))
            return pyccn.RESULT_OK

        rrset = self._ndns.query (ndns.RRSet).with_parent (zone).filter_by (label = label.to_text (), rtype = rrtype).first ()

        # the big question is what to do when there is no data..
        # .. this is more a theory question, than the implementation. For now we just don't return anything and client will timeout

        if not rrset:
            _LOG.debug ("(!!! no action defined yet!!!) The requested record (%s %s) not found in zone [%s]" %
                        (label.to_text (), dns.rdatatype.to_text (rrtype), zoneName))
            return pyccn.RESULT_OK

        dataPacket = rrset.ndndata
        if interest.name[:] != dataPacket.name[:len(interest.name)]:
            _LOG.debug ("Request is not in a canonical form (e.g., case mistmatch), requested data found, but cannot be returned")
            _LOG.debug ("        Could be version mistmatch")
            return pyccn.RESULT_OK

        _LOG.debug ("<< Found a valid record, returning data object [%s]" % dataPacket.name)
        self._face.put (dataPacket)

        return pyccn.RESULT_OK

# main
if( __name__ == '__main__' ):
    ndns_daemon = NdnsDaemon ()

    context = daemon.DaemonContext (
        working_directory = _WORKDIR,
        detach_process = not args.foreground,
        )
    if args.foreground:
        context.stdout = sys.stdout
        context.stderr = sys.stderr

    context.signal_map = {
        signal.SIGTERM: lambda signum, frame: ndns_daemon.terminate (),
        signal.SIGQUIT: lambda signum, frame: ndns_daemon.terminate (),
        signal.SIGINT:  lambda signum, frame: ndns_daemon.terminate (),
        signal.SIGUSR1: lambda signum, frame: ndns_daemon.reloadConfig (),
    }

    with context:
        discovery = pyccn.LocalPrefixDiscovery (periodicity = 5)
        discovery.subscribe ("ndns", ndns_daemon.updateLocalPrefix)

        ndns_daemon.run ()
        discovery.shutdown ()
